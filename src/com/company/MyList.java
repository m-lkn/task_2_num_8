package com.company;

public class MyList<T> {
    // созданный класс односвязного списка
    // (список состоит из узлов со значениями, ссылающихся друг на друга в определённом порядке)

    class Node<T> {
        // содержмиое любого узла
        T value; // значение
        Node<T> next; // ссылка на следующий за ним узел

        // конструктор для создания узла
        public Node(T value, Node<T> next) {
            this.value = value;
            this.next = next;
        }
    }

    Node<T> head;       // самый первый узел списка - "голова" (англ. head)
    Node<T> tail;       // самый последний узел списка - "хвост" (англ. tail)
    int length = 0;     // длина списка (кол-во узлов в нём)

    // после хвоста узлов больше нет, поэтому tail ссылается на null (пустоту)

    // метод добавления нового узла в конец
    public void add(T value) {
        // если длина 0, то список пустой, и новый узел окажется для него и первым, и последним
        if (length == 0) {
            head = tail = new Node<>(value, null);
        } else {
            // во всех остальных случаях делаем это:

            // создаём новый узел
            Node<T> newNode = new Node<>(value, null);

            // сохраняем что после текущего хвоста будет наш новый узел
            tail.next = newNode;

            // после текущего хвоста теперь есть ещё один, наш новый,
            // поэтому теперь хвостом будет новый
            tail = newNode;
        }

        // увеличиваем длину на 1, т.к. мы добавили 1 новый узел
        length++;
    }

    // вызов метода задачи: удаление одинаковых узлов, идущих подряд
    public void removeRepeatsInRow() {
        // вызываем рекурсию, начиная с головы
        removeRepeatsInRow(head);
    }

    // рекурсия
    private void removeRepeatsInRow(Node<T> curNode) {
        // входная переменная - curNode (current Node) текущий узел - узел в которым мы сейчас находимся

        // если следующий узел отсутствует, то сравнивать больше нечего
        if (curNode.next == null) return;

        // если значение текущего узла не совпадает со значением следующего за ним
        if (!curNode.value.equals(curNode.next.value)) {
            // о просто переходим к следующему узлу(вызываем рекурсию для след. узла)
            removeRepeatsInRow(curNode.next);
        } else {
            // если же они совпадают то удаляем следующий:
            // в текущий узел кладём ссылку сразу на узел после следующего

            // следующий узел "выпадет" из последовательности и перестанет для неё существовать,
            // т.к. в последовательности нет узлов, которые на него ссылаются
            curNode.next = curNode.next.next;

            // после удаления после-следующий узел становится следующим для текущего
            if (curNode.next != null) {
                // мы их не сравнивали, а должны
                // поэтому вызываем роекурсию не для следующего узла, а ещё раз для текущего
                removeRepeatsInRow(curNode);
            }
        }
    }

    // перевод списка в строку
    public String toString() {
        //создаём строку
        String str = "[";

        // начиная с первого узла добавляем значения каждого узла + пробел в строку
        // пока не встретим последний - хвост
        Node<T> curNode = head;
        while (curNode != tail) {
            str += curNode.value + ", ";

            curNode = curNode.next;
        }

        // добавляем значение последнего и возвращаем полученную строку
        str += tail.value + "]";
        return str;
    }
}
